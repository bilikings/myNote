## 要点

1. Java引用的功能和意义
2. Java引用与内存回收之间的关系
3. Java对象在内存中的不同状态
4. 软引用的作用和使用软引用的注意点
5. 弱引用的作用和使用弱引用的注意点
6. 虚引用的作用和使用虚引用的注意点
7. Java内存泄漏的原因
8. Java内存泄漏和C++内存泄漏的差别
9. Java垃圾回收机制的基本算法
10. 堆内存的分代回收
11. Young代、Old代和Permanent代的各自存储的对象
12. Young代、Old代和Permanent代的特定及适用的回收算法
13. 常见垃圾回收机制对堆内存的回收细节

## 对象在内存中的状态

对于GC来说，是否回收一个对象的标准在于，是否几率引用变量在引用这个对象。

基本上，可以把JVM内存中的对象引用理解成一种**有向图**，引用变量、对象都当成为有向图的顶点，将引用关系当成图的有向边，有向边总是从引用端指向被引用的Java对象，图的起始顶点是**线程对象**。

一个对象在堆内存中运行时，根据图中状态，可以有下面三种状态：

1. 可达状态：一个状态在被创建之后，有一个以上的变量引用他，在有向图的起始顶点可以导航到这个对象，那么他就处于可达状态

2. 可恢复状态：如果成行中不在有任何的引用变量引用他，那么就先进入可恢复状态，有向图顶点不可达。

3. 不可达状态：当系统调用finalize方法仍然不能让可恢复状态称为可达状态，那么这个对象就永久的失去引用，成为不可达状态，这时才会真正的垃圾回收。

   **![image-20201020150450069](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201020150450069.png)**

   ## 对象的引用类型

   ​		对于垃圾回收机制来说，判断一个对象是否可以进行回收的标准就在于这个对象是不是被引用，所以引用是JVM进行内存管理的一个重要工具，

   Java的4个引用类型如下

   1. 强引用
   2. 软引用
   3. 弱引用
   4. 虚引用

### 强引用

这是Java程序中最常见的引用方式，程序创建一个对象，并把这个对象赋给一个引用变量，这个引用变量就是强引用。

由于JVM肯定不会回收强引用所引用的Java对象，因此强引用是造成Java内存泄漏的主要原因之一。

### 软引用

软引用需要通过`SoftReference`类来实现，当一个对象只具有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象；当系统内存空间不足时，系统将会回收它。

当系统内存充足时，`SoftReference`引用和强引用并没有太大的区别。当程序使用强引用时，无论系统堆内存如何紧张，JVM垃圾回收机制都不会回收被强引用所引用的Java对象，因此最后导致程序因内存不足而中止。但如果程序把强引用改为使用软引用，就可完全避免这种情况，这就是软引用的优势所在。

### 弱引用

弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。

### 虚引用

软引用和弱引用可以单独使用，但虚引用不能单独使用，单独使用虚引用没有太大的意义。虚引用的主要作用就是跟踪对象被垃圾回收的状态，程序可以通过检查与虚引用关联的引用队列中是否已经包含指定的虚引用，从而了解虚引用所引用对象是否即将被回收。

与软引用和弱引用不同的是，虚引用在对象被释放之前，将把它对应的虚引用添加到它的关联的引用队列中，这使得可以在对象被回收之前采取行动。

虚引用通过`PhantomReference`类实现，它完全类似于**没有引用**。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。

虚引用主要用于**跟踪对象被垃圾回收的状态**，虚引用不能单独使用，虚引用必须和引用队列（`ReferenceQueue`）联合使用。

## Java内存泄漏

程序运行过程中会不断地分配内存空间，那些不再使用的内存空间应该即时回收它们，从而保证系统可以再次使用这些内存，如果存在无用的内存没有被回收回来，那就是**内存泄漏**。

java中的内存泄漏主要针对那些**无用却可达**的对象，而c++中针对的是**无用**的对象，需要程序员手动释放。

对于Java程序而言，只要它们一直处于可达状态，垃圾回收机制就不会回收它们—即使它们对于程序来说已经变成了垃圾（程序再也不需要它们了），而对于垃圾回收机制来说，它们还不是垃圾（还处于可达状态），因此不能回收。

## 垃圾回收机制

主要完成两件事情

+ 跟踪并监控每个Java对象，当一个对象处于不可达状态是，回收对象分配的内存
+ 清理内存分配、回收是产生的内存碎片

### 基本算法

实际上，垃圾回收机制不可能实时检测到每个Java对象的状态，因此当一个对象失去引用后，它也不会被立即回收，只有等垃圾回收运行时才会被回收。

设计思路：

+ 串行回收与并行回收
+ 并发执行和引用程序停止
+ 压缩，不压缩，复制
  + 复制：将堆内分成两个相同空间，从根（类似于前面介绍的有向图的起始顶点）开始访问每一个关联的可达对象，将空间A的可达对象全部复制到空间B，然后一次性回收整个空间A。
  + 标记清除：经典的不压缩算法，垃圾回收器先从根开始访问所有可达对象，将它们标记为可达状态，然后再遍历一次整个内存区域，把所有没有标记为可达的对象进行回收处理。
  + 标记压缩：垃圾回收器先从根开始访问所有可达对象，将它们标记为可达状态。接下来垃圾回收器会将这些活动对象搬迁在一起，这个过程也被称为内存压缩，然后垃圾回收机制再次回收那些不可达对象所占用的内存空间，这样就避免了回收产生的内存碎片。有3个阶段：mark（标识可达对象）、sweep（清除）、compact（压缩）。
    + 在 mark阶段，回收器会识别出哪些对象仍然是可达的
    + 在 sweep阶段将会回收不可达对象所占用的内存
    + 在compact阶段回收器执行`slidingcompaction`，把活动对象往Old代的前端启动，而在尾部保留一块连续的空间，以便下次为新对象分配内存空间。

### 内存分代回收

+  Young（年轻代）：采用复制算法
+  Old（老年代）：采用标记压缩算法
+  Permanent（永久代）

在不同的代中，采用不同的回收算法

+ 绝大对数的对象不会被长时间引用，这些对象在其Young期间就会被回收
+ 很老的对象（生存时间很长）和很新的对象（生存时间很短）之间很少存在相互引用的情况。

#### young代

Young代由1个Eden区和2个Survivor区构成。绝大多数对象先分配到Eden区。同一时间2个Survivor空间中有一个用来保存对象，而另一个是空的，用来在下次垃圾回收时保存Young代中的对象。

Eden和Survivor的比例通过`-XX:SurvivorRatio`附加选项来设定，默认为32。

#### old代

执行垃圾回收的频率无需太高，久经考验的对象很少会死掉

每次 Old的垃圾回收需要更长的时间

#### permanent代

主要用于转载Class，方法等信息，默认为64M

通常不会对这里面的对象执行垃圾回收

